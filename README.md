# ğŸ›ï¸ Adopted Architecture

## Architectural Style: Clean Architecture

Clean Architecture is a software design structure composed of multiple layers, promoting an organized and easy-to-understand structure, which is beneficial for development.

Its main feature is the separation and independence of layers, such as decoupling business logic from external influences like the user interface (UI), frameworks, databases, etc. This is achieved by defining an independent and isolated domain layer.

### ğŸ§  Core Principles of Clean Architecture:

- **Technology independence**: The system core (business rules) does not depend on frameworks, libraries, or I/O details.
- **Dependency rule**: The flow of dependencies always points inward â€” external interfaces depend on the domain, never the opposite.
- **Isolated business rules**: Enables reuse in other contexts (e.g., CLI, APIs, graphical interfaces).

The main idea of Clean Architecture is to separate code into concentric layers, where:

ğŸ”„ **Dependencies always point inward:**


```

+------------------------+
| External Layer | <- User interface, web, database, etc.
+------------------------+
| Interface Adapters | <- Controllers, Gateways, Presenters
+------------------------+
| Use Cases Layer | <- Application business rules
+------------------------+
| Entities (Core) | <- Generic business rules
+------------------------+
```


---

## ğŸ“¦ The Layers:

- **Frameworks & Drivers (outermost layer):**  
  Where external tools and services reside, such as frameworks, databases, UI, and third-party services.

- **Interface Adapters:**  
  The layer that transforms data for input/output (e.g., controllers, presenters, repositories).

- **Use Cases:**  
  Application-specific business rules that orchestrate the logic to solve specific domain problems.

- **Entities:**  
  The most generic and reusable business rules, independent of technology or application context.

---

---

## ğŸ§© Application in the Test.AI Context

| Layer           | Description                                                          | Examples                                             |
|------------------|----------------------------------------------------------------------|------------------------------------------------------|
| Interface        | User interaction layer via VS Code API or Streamlit                 | Commands like "Generate BDD", "Generate Steps"       |
| Application      | Defines the main flows and orchestration rules                      | Scripts that coordinate agents and tasks             |
| Domain           | Pure business rules                                                  | Generation and review of `.feature` files with CrewAI |
| Infrastructure   | Manages OS interaction, file system, environment, and LLMs          | FastAPI, reading `.env`, logs, calling LLMs          |

---

## ğŸ–¥ï¸ Interface in Test.AI

### ğŸ“Œ Description

The **Interface layer** is responsible for directly interacting with the **end user**. In the Test.AI project, this interaction is done through a **Streamlit application**, which serves as the visual presentation layer, displaying the data generated by APIs and capturing user commands.

This layer does not process business logic but acts as a bridge between the user and the application.

---

### ğŸ” Code Snippets Related to the Interface

**File:** `src/scripts/comparacao.py`

| Code Snippet                         | Description                                | Interface Role                         |
|--------------------------------------|--------------------------------------------|----------------------------------------|
| `import streamlit as st`             | Imports the GUI library                    | Initializes the web interface layer     |
| `user_input = data_json['payload']`  | Loads user input from a JSON               | Captures input to be sent to the APIs  |
| `if st.button("Enviar"):`           | Creates a submit button                    | Triggers processing on click           |
| `col1, col2 = st.columns([1, 1])`   | Creates two visual columns                 | Splits model responses (Debate, Sequential) |
| `st.session_state['messages'].append(...)` | Stores session messages              | Controls interaction history           |
| `st.write(...)`                      | Displays input and output                  | Shows data on screen                   |
| `if st.button("Clear Chat"):`       | Creates a button to clear session          | Resets interface and conversation log  |

---

### âœ… Summary

The Interface layer in Test.AI acts as a **visual control panel** of the application. It is responsible for:

- **Receiving user input**
- **Sending data to external APIs (Debate and Sequential)**
- **Displaying the results in a clear and organized way**
- **Maintaining interactive session history**
- **Resetting the interface on demand**

---

## ğŸ§  Application Layer in Test.AI

### ğŸ“Œ Description

The **Application layer** can be considered the core of the project. As the name suggests, it is where the logic defined in the Domain layer is executed and materialized into real use cases.

It defines how the application behaves and orchestrates the agents and their interactions.

---

### âœ… Summary

The Application layer in Test.AI is the **engine** of the system. It is responsible for:

- **Executing BDD generation use cases**
- **Controlling agent interactions and workflows**
- **Isolating business logic from the interface**
- **Storing agent definitions**
- **Managing task configuration files**

---

## ğŸ§  Domain Layer in Test.AI

### ğŸ“Œ Description

The **Domain layer** in **Test.AI** contains the **core business logic** of the system. It ensures all data interpretation and test file generation actions are performed correctly and efficiently.

This layer is **independent from frameworks and external technologies**, allowing for easier testing, maintenance, and changes without affecting the rest of the system.

---

### ğŸ” How It Works

1. **LLM Initialization**:
   - Uses two LLM configurations (different temperatures): one more creative (`temp=0.6`) and one more precise (`temp=0.0`).
   - Functions like `init_llm`, `init_agent`, and `init_task` are imported from `module.py`.

2. **Generation Rounds**:
   - Runs 3 rounds to generate and review `.feature` files.
   - Each round:
     - A **gherkin_writer** agent writes Gherkin code.
     - A **gherkin_reviewer** agent reviews it.
     - Agents are dynamically configured with round context (e.g., `round_1`, `round_2`, etc.).

3. **Task Definitions**:
   - Tasks are dynamically created using `tasks_dict`, inserting the `user_case` into the task descriptions.

4. **Crew Structure**:
   - Uses the `crewai` library to coordinate multiple agents (`Agent`, `Task`, `Crew` classes).

#### ğŸ§  Artificial Intelligence

The integration with LLMs enables agents to generate more natural and structured Gherkin code even from simple inputs.

---

### âœ… Summary

This script represents a component of the **Domain Layer** that automates **collaborative BDD test creation** using AI and multiple specialized agents. It is the core logic that converts textual requirements into executable tests.

---

## ğŸ§± Infrastructure Layer in Test.AI

### ğŸ“Œ Description

This module defines the backend infrastructure of Test.AI using FastAPI, with support for CORS, REST requests, and LLM integration via CrewAI. Its main focus is receiving POST events that are processed by intelligent agents to generate Gherkin test files.

*CORS is a mechanism to allow web apps from one origin to access resources from another origin via HTTP headers.*

---

### ğŸ” Code Snippets Related to Infrastructure

**File:** `src/app/main.py`

```python
crew = Crew(
    agents=agents + [manager],
    tasks=tasks + [final_task],
    max_rpm=10,
    output_log_file="crew_log.txt",
    manager_llm=llm_low_temp,
    process=Process.sequential,
    verbose=True
)
```
- Defines a Crew with multiple agents and tasks, executing sequentially with logs saved to crew_log.txt

```
load_dotenv()
```

- Loads environment variables from .env, needed for API keys (e.g., GOOGLE_API_KEY).
```
@app.get("/")
async def home():
return "Rodando"
```

- Basic endpoint to check if the application is running.

```
@app.post("/gherkin")
async def generate_gherkin_file(evento: Evento):
feature = generate_gherkin_feature(evento.evento)
body = {
"feature": feature
}
return JSONResponse(body)
```


- The main endpoint /gherkin receives an event, processes it via agents, and returns a Gherkin .feature file.



- he generate_gherkin_feature function creates multiple agents (writers and reviewers), each with specific roles in constructing and verifying test scenarios. A manager agent synthesizes the best results into a single .feature file.

---

### âœ… Summary

- Backend built with FastAPI, with CORS support.

- Uses the CrewAI library to orchestrate intelligent agents based on LLMs (Gemini model via `GOOGLE_API_KEY`).

- POST input at `/gherkin` receives events and transforms them into BDD scenarios (Gherkin).

- The generation process involves multiple agents:

  - Writers and reviewers for Gherkin scenarios.

  - A manager that consolidates the generated versions.

- Final result is saved in a `.feature` file and logged in `crew_log.txt`.

## ğŸŒ Technologies in Front-end vs Back-end

| Layer      | Technology                     | Description                                                                 |
|------------|--------------------------------|-----------------------------------------------------------------------------|
| Front-end  | VS Code Extension (TypeScript) | Handles user interaction and command execution.                            |
| Back-end   | Python (`test-ai-leds`)        | Processes data, interprets files, and generates test code.                 |
| Back-end   | CrewAI                         | Multi-agent framework used to automate test generation workflows.          |
| Back-end   | LLM model                      | Uses the Gemini 1.5 Flash model as the LLM backend.                        |

## ğŸ“š References

1. https://medium.com/@gabrielfernandeslemos/clean-architecture-uma-abordagem-baseada-em-princÃ­pios-bf9866da1f9c  
2. https://www.alura.com.br/artigos/como-resolver-erro-de-cross-origin-resource-sharing?srsltid=AfmBOorV-xhK1EvpyB2zY9hm9hDnIj3HivlXWoIbFQJZE9jbESQLfXbC  
3. https://requests.readthedocs.io/en/latest/  
4. https://docs.streamlit.io  
5. https://github.com/leds-org/leds-tools-public/blob/main/docs/test_ai/img/fluxograma_gherkin.png

## âš ï¸ Note

**The `scripts` folder contains code to test the `task` and `agent` entities, which have been refactored.**

